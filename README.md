# Assignment 4 - Graphs (ADS)

This project implements Breadth-First Search (BFS) and Dijkstra's algorithm for an edge-weighted graph. The primary focus of this assignment is to refactor the graph's internal representation: instead of the graph managing a list of `Edge` objects, the `Vertex` class itself now holds information about its adjacent vertices and the weights of the edges connecting to them.

The implementation aims to be compatible with the `Main.java` class provided in the example repository (`https://github.com/aghia7/example.git`), allowing it to run without modifications.

## Core Refactoring

The main change from a typical lecture example (where `Edge` objects are central to the graph's adjacency list) is the structure of the `Vertex` and `WeightedGraph` classes:

*   **Previous Approach (Hypothetical/Lecture Example):**
    *   `Edge<Vertex>` class might have: `source`, `dest`, `weight`.
    *   `WeightedGraph` class might have an adjacency list like: `Map<Vertex, List<Edge<Vertex>>> map`.

*   **Implemented Approach (This Assignment):**
    *   **`Vertex<V>` class:**
        *   `private V data;`
        *   `private Map<Vertex<V>, Double> adjacentVertices; // Neighbor -> Weight`
        This map directly stores a vertex's neighbors and the weight of the edge leading to that neighbor.
    *   **`WeightedGraph<V>` class:**
        *   Manages a collection of these refactored `Vertex` objects.
        *   Adding an edge (e.g., `addEdge(sourceVertex, destVertex, weight)`) involves telling the `sourceVertex` to add `destVertex` to its `adjacentVertices` map with the given `weight`. For undirected graphs, the reverse is also done.

This change simplifies how adjacency information is accessed, as it's directly available from the `Vertex` object.

## Project Structure and Classes

The project is organized within the `graphassignment` package and includes the following main Java files:

*   **`Vertex.java`**: Represents a node in the graph. Now contains its data and a map of its adjacent vertices to the corresponding edge weights. Implements `equals()` and `hashCode()` based on its data for proper functioning in HashMaps and Sets.
*   **`WeightedGraph.java`**: Represents the graph structure. Manages a set of `Vertex` objects and provides methods to add vertices and edges. Edge information is now primarily stored within the `Vertex` objects. It uses a `Map<V, Vertex<V>>` to ensure canonical `Vertex` objects are used throughout.
*   **`Search.java`**: An interface defining the contract for search algorithms. It has one method: `List<Vertex<V>> search(Vertex<V> startNode, Vertex<V> endNode);`.
*   **`BreadthFirstSearch.java`**: Implements the `Search` interface for Breadth-First Search. Finds the shortest path in terms of the number of edges. Ignores edge weights for pathfinding logic but uses the new `Vertex.getAdjacentVertices()` method.
*   **`DijkstraSearch.java`**: Implements the `Search` interface for Dijkstra's algorithm. Finds the shortest path in terms of total edge weight, utilizing the weights stored in `Vertex.getAdjacentVertices()`.
*   **`DepthFirstSearch.java`**: Implements the `Search` interface for Depth-First Search. Finds *a* path between two nodes (not necessarily shortest). Adapted to use the new `Vertex` structure.
*   **`Main.java`**: Contains the `main` method to demonstrate the functionality of the graph and search algorithms. This `Main.java` is the one provided in the example repository and runs correctly with the refactored classes.
*   **`Edge.java`**: The original `Edge` class (source, destination, weight). While not central to the new `WeightedGraph`'s adjacency representation, it's kept for completeness or if other algorithms might specifically require `Edge` objects.
*   **`UnweightedGraph.java`**: The original `UnweightedGraph` class. The assignment's focus was on refactoring `WeightedGraph`, so this class is largely included as per the original file list.
*   **`PathFinder.java`**: A helper utility class with a static method `reconstructPath`. This method takes the end node and a map of predecessors (generated by the search algorithms) to reconstruct the actual path. This promotes code reusability by centralizing path reconstruction logic.

## Setup and Running

1.  **Prerequisites:**
    *   Java Development Kit (JDK) installed (e.g., JDK 11 or newer).
    *   IntelliJ IDEA (or any other Java IDE compatible with standard Java projects).

2.  **Setup:**
    *   Clone this repository or download the source files.
    *   Open the project in IntelliJ IDEA.
        *   If downloaded as a ZIP, extract it first.
        *   In IntelliJ, choose "Open..." and navigate to the project's root folder.
    *   Ensure all `.java` files are located within a package named `graphassignment`. If you use a different package name, you'll need to update the `package` declarations at the top of each Java file.

3.  **Running the Example:**
    *   Navigate to the `Main.java` file (usually located at `src/graphassignment/Main.java`).
    *   Right-click on the `Main.java` file in the Project view (or within the editor).
    *   Select "Run 'Main.main()'".
    *   The output, demonstrating various graph searches (Dijkstra, BFS, DFS) on a sample graph of cities, will be displayed in the console.

## Example Output

The `Main.java` class will execute several search queries. An example of the expected output is:
Dijkstra Search from Almaty to Kokshetau:
Almaty -> Astana -> Kokshetau
Total weight: 3.2
Breadth-First Search from Almaty to Kokshetau (shortest in terms of edges):
Almaty -> Astana -> Kokshetau
Total weight (for BFS path): 3.2
Depth-First Search from Almaty to Kokshetau:
Almaty -> Astana -> Kokshetau
Total weight (for DFS path): 3.2
Example: Path from Shymkent to Pavlodar using Dijkstra
Shymkent -> Astana -> Pavlodar
Total weight: 7.7
Example: Path from Almaty to Almaty (should be just Almaty)
Almaty
Total weight: 0.0
Example: Path to non-existent/unreachable (e.g. if Qostanay was isolated)
No path found.
Total weight: 0.0

## Design Notes

*   **Vertex-centric Adjacency:** The key design decision was to make `Vertex` objects responsible for knowing their direct neighbors and the weights of the edges to them. This aligns with the assignment's requirement.
*   **Compatibility with Provided `Main.java`:** Care was taken to ensure that the constructors and public method signatures of `WeightedGraph`, `Vertex`, and the search algorithm classes match what the original `Main.java` expects.
*   **Helper Utility (`PathFinder.java`):** To avoid repetitive code for reconstructing paths from predecessor maps in each search algorithm, a `PathFinder` utility class with a static method was created. This improves code maintainability and adheres to the DRY (Don't Repeat Yourself) principle.
